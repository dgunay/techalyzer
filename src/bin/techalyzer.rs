use std::{fs::File, path::PathBuf};
use structopt::StructOpt;
use techalyzer::error::TechalyzerError;
use techalyzer::get_market_data;
use techalyzer::secret::Secret;
use techalyzer::subcommands::*;
use techalyzer::{
    config::{GeneralParams, TrainingParams},
    date::{today, Date},
    indicators::SupportedIndicators,
    marketdata::prices::PricesError,
    signals::Signal,
    trading::{
        buyandhold::BuyAndHold,
        dtmodel::{DecisionTreeTrader, Trained},
        manual::ManualTradingModel,
        SupportedTradingModel,
    },
    util::last_key,
};

/// A hobby tool for machine learning and technical analysis trading insights.
///
/// The outputs, source code, and views of the authors of Techalyzer are not
/// professional or financial advice.
#[derive(StructOpt, Debug)]
#[structopt(name = "Techalyzer", author = "Devin Gunay <devingunay@gmail.com>")]
struct Opts {
    #[structopt(flatten)]
    params: GeneralParams,

    #[structopt(subcommand)]
    cmd: SubCommands,
}

#[derive(StructOpt, Debug)]
enum SubCommands {
    /// Using time series price data, prints a technical indicator and the
    /// normalized signals generated by Techalyzer to STDOUT as JSON data.
    Print {
        #[structopt(short, long)]
        indicator: SupportedIndicators,

        /// Print buy/sell signals along with the indicator
        #[structopt(short, long)]
        print_signals: bool,
    },

    /// Trains a machine learning model on stock data to make trades based on
    /// technical indicators, then serializes it for later use.
    Train {
        // FIXME: We can't have flattened structs as part of groups, so hacks
        // abound here in order to get mutual exclusion between TrainingParams
        // and paramfile.
        #[structopt(flatten)]
        params: TrainingParams,

        // TODO: make paramfile override-able using params.
        /// A file with training parameters as JSON.
        #[structopt(short, long)]
        paramfile: Option<PathBuf>,

        // TODO: find a way to express this default in code without inlining it
        // into the Train function and hardcoding the default here. There has to
        // be a way to get around Default not allowing a dynamic symbol name.
        /// File path to output a model file to [default: <symbol>.bin]
        #[structopt(long, short)]
        out_path: Option<PathBuf>,
    },

    /// Suggests a trading course of action given recent developments in a
    /// security's price action.
    Suggest { model: SupportedTradingModel },

    /// Backtests a strategy through a given dataset
    Backtest {
        /// Which trading model to use.
        trading_model: SupportedTradingModel,

        // FIXME: can't take advantage of default values because of how
        // required_if works :/ needs an Option, which we can't use with
        // default_value.

        // ManualTradingAlgo params
        #[structopt(long, required_if("trading-model", "ManualTradingAlgo"))]
        shares: Option<u64>,

        #[structopt(long, required_if("trading-model", "ManualTradingAlgo"))]
        dead_zone: Option<Signal>,

        #[structopt(long, required_if("trading-model", "ManualTradingAlgo"))]
        disposition: Option<Signal>,

        /// Saved model file to use (generate one with `techalyzer train`)
        #[structopt(long, short, required_if("trading-model", "MachineLearningModel"))]
        model_file: Option<PathBuf>,

        /// How much cash the model begins with.
        cash: f64, // TODO: is there a good money type/bignum to avoid possible problems?
    },
}

fn main() -> Result<(), TechalyzerError> {
    let opts = Opts::from_args();
    match run_program(opts) {
        Ok(_) => Ok(()),
        Err(e) => {
            println!("{}", e);
            Err(e)
        }
    }
}

fn very_early_date() -> Date {
    Date::from_ymd(1000, 1, 1)
}

/// Wrappable main function to make it easier to test.
fn run_program(opts: Opts) -> Result<(), TechalyzerError> {
    let params = opts.params;

    // Date range for the data
    let start = params.start_date;
    let end = params.end_date;

    // API keys if necessary
    let secret = Secret {
        data: params.secret,
    };

    let start_date = start.unwrap_or_else(very_early_date);
    let end_date = end.unwrap_or_else(today);

    // Get market data
    let prices = match get_market_data(
        params.data_source,
        params.symbol,
        start_date..=end_date,
        secret,
    ) {
        Ok(d) => d,
        Err(e) => {
            return Err(TechalyzerError::Generic(format!("{}", e)));
        }
    };

    // Run a subcommand
    match opts.cmd {
        SubCommands::Print {
            indicator,
            print_signals: _,
        } => {
            // TODO: evaluate/benchmark signal generation using ndarray vs Vec<f64>
            print(prices, indicator)?;
        }
        SubCommands::Suggest { model: _ } => todo!("Suggest not yet implemented"),
        SubCommands::Train {
            params: p,
            out_path,
            paramfile,
        } => {
            // Paramfile is our default if it is present, otherwise use passed params.
            let params: TrainingParams = match paramfile {
                Some(path) => {
                    let p: TrainingParams = serde_json::from_reader(File::open(path)?)?;
                    // TODO: override parameters if cli ones are present
                    p
                }
                None => p,
            };

            // TODO: implement a verbose flag
            // dbg!(&params);

            if params.signal_generators.is_empty() {
                return Err(TechalyzerError::NoIndicatorSpecified);
            }

            let start_date = match params.train_start_date {
                Some(d) => d,
                None => {
                    *prices
                        .first_entry()
                        .ok_or_else(|| "Could not find first entry in dataset".to_string())?
                        .0
                }
            };

            // Manual end date or -horizon days before the end of the dataset.
            let end_date = match end {
                // if it's some end date, index into the prices until we're
                // horizon days before it
                Some(d) => {
                    prices
                        .get_before(&d, params.horizon.0)
                        .ok_or(PricesError::DateNotFound(d))?
                        .0
                }
                // else use the last n days
                None => {
                    last_key(&prices.map)
                        .and_then(|d| prices.get_before(&d, params.horizon.0))
                        .ok_or(format!(
                            "Could not find {} days before last day in price data",
                            params.horizon
                        ))?
                        .0
                }
            };

            // Copy our training dates out of the Price data set.
            let range: Vec<Date> = prices
                .date_range(start_date..=end_date)
                .map
                .keys()
                .cloned()
                .collect();

            // TODO: include date info
            // FIXME: need a way to output to null for testing
            let out_path =
                out_path.unwrap_or_else(|| PathBuf::from(format!("{}.bin", &prices.symbol)));
            train(
                prices,
                range,
                params.signal_generators.into(),
                params.horizon,
                out_path,
            )?
        }
        SubCommands::Backtest {
            trading_model,
            cash,
            model_file,
            dead_zone,
            disposition,
            shares,
        } => {
            match trading_model {
                // TODO: don't unwrap
                SupportedTradingModel::BuyAndHold => {
                    backtest(prices, BuyAndHold::default(), cash)?;
                }
                SupportedTradingModel::ManualTradingAlgo => {
                    let (shares, dead_zone, disposition) =
                        (shares.unwrap(), dead_zone.unwrap(), disposition.unwrap());
                    backtest(
                        prices,
                        ManualTradingModel::new(shares, dead_zone, disposition),
                        cash,
                    )?;
                }
                SupportedTradingModel::MachineLearningModel => {
                    let model: DecisionTreeTrader<Trained> = match model_file {
                        Some(path) => bincode::deserialize(std::fs::read(path)?.as_slice())?,
                        None => return Err(TechalyzerError::NoModelFileSpecified),
                    };
                    backtest(prices, model, cash)?;
                }
            };
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::SupportedIndicators;
    use super::{run_program, Opts, SubCommands};
    use crate::TrainingParams;
    use techalyzer::{
        config::GeneralParams, datasource::SupportedDataSource, date::Date, util::Symbol,
    };
    use tempfile::NamedTempFile;

    #[test]
    fn end_to_end_print_rsi() {
        // Basic smoke test that the program can go end to end
        let res = run_program(Opts {
            params: GeneralParams {
                data_source: SupportedDataSource::TechalyzerJson("test/json/jpm_rsi.json".into()),
                secret: None,
                symbol: Symbol::new("JPM".to_string()),
                start_date: None,
                end_date: None,
            },
            cmd: SubCommands::Print {
                indicator: SupportedIndicators::RelativeStrengthIndex,
                print_signals: true,
            },
        });

        res.unwrap();
    }

    // TODO: test behavior of each path (mainly whether required arguments work
    // properly or not)

    #[test]
    fn training_end_date() {
        // Regression test for this issue:
        //
        // Running Train with this date range causes errors.
        // The desired behavior should be that it trains on data from up to
        // 10 trading days before 2020-06-02, but it seems to not line up that
        // way.
        let file = NamedTempFile::new().unwrap();
        let _ = run_program(Opts {
            params: GeneralParams {
                secret: None,
                data_source: SupportedDataSource::TechalyzerJson("test/json/jpm_rsi.json".into()),
                symbol: Symbol::new("JPM".to_string()),
                start_date: None,
                end_date: Some(Date::from_ymd(2020, 06, 02)),
            },
            cmd: SubCommands::Train {
                params: TrainingParams::default(),
                out_path: Some(file.path().to_path_buf()),
                paramfile: Default::default(),
            },
        })
        .unwrap();
    }

    #[test]
    #[should_panic]
    fn test_open_csv() {
        // TODO: test happy and invalid csv open paths
        todo!("test happy and invalid csv open paths")
    }

    #[test]
    #[should_panic]
    fn test_open_json() {
        // TODO: test happy and invalid json open paths
        todo!("test happy and invalid json open paths")
    }
}
